#include <uart.h>


// ***** MODIFIED TO NOT GET STUCK WAITING FOR INPUT *****
uint8_t USART_Read (USART_TypeDef * USARTx) {
	// SR_RXNE (Read data register not empty) bit is set by hardware
	while (!(USARTx->ISR & USART_ISR_RXNE_RXFNE));
	// USART resets the RXNE flag automatically after reading DR
	return ((uint8_t)(USARTx->RDR & 0xFF));
	// Reading USART_DR automatically clears the RXNE flag 
}

void get_line(char *buffer, int max_length) {
	uint16_t count = 0;

	do {
		// Get last entered Input
		buffer[count] = USART_Read(USART2);
		// Write it to the screen
		USART_Write(USART2, (uint8_t *)&buffer[count], 1);
		// increase count so we know amount of characters inputed
		count++;
	}
	// While we do no have an enter input
	while(buffer[count-1] != CARRAIGE_RETURN);
}


void USART_Write(USART_TypeDef * USARTx, uint8_t *buffer, uint32_t nBytes) {
	int i;
	// A byte to be transmitted is written to the TDR (transmit data register), and the TXE (transmit empty) bit is cleared.
	// The TDR is copied to an output shift register for serialization when that register is empty, and the TXE bit is set.
	for (i = 0; i < nBytes; i++) {
		while (!(USARTx->ISR & USART_ISR_TXE_TXFNF))
			;   							// wait until TXE (TX empty) bit is set
		USARTx->TDR = buffer[i] & 0xFF;		// writing USART_TDR automatically clears the TXE flag
	}
	while (!(USARTx->ISR & USART_ISR_TC))
		;  									// wait until TC bit is set
	USARTx->ISR &= ~USART_ISR_TC;
}

void print(USART_TypeDef * USARTx, char *string) {
	uint32_t size = sprintf(string, string);
	USART_Write(USARTx, (uint8_t *)string, size);
}

void USART_IRQHandler(USART_TypeDef * USARTx, uint8_t *buffer, uint32_t * pRx_counter){
	if(USARTx->ISR & USART_ISR_RXNE_RXFNE) {						// Received data
		buffer[*pRx_counter] = USARTx->RDR;         // Reading USART_DR automatically clears the RXNE flag 
		(*pRx_counter)++;  
		if((*pRx_counter) >= BufferSize )  {
			(*pRx_counter) = 0;
		}   
	} else if(USARTx->ISR & USART_ISR_TXE_TXFNF) {
		//USARTx->ISR &= ~USART_ISR_TXE;            // clear interrupt
		//Tx1_Counter++;
	} else if(USARTx->ISR & USART_ISR_ORE) {			// Overrun Error
		while(1);
	} else if(USARTx->ISR & USART_ISR_PE) {				// Parity Error
		while(1);
	} else if(USARTx->ISR & USART_ISR_PE) {				// USART_ISR_FE	
		while(1);
	} else if (USARTx->ISR & USART_ISR_NE){ 			// Noise Error Flag
		while(1);     
	}	
}

